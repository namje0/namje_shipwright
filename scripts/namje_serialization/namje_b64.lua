-- This Lua Base64 module and table serialization/deserialization
-- functions were generated by Google Gemini.
-- Date generated: October 6, 2025
-- For more information, visit: https://gemini.google.com/
-- why code it by hand when robots do it faster?

namje_b64 = {}

-- The Base64 index table (alphabet)
local BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

--- Encodes a binary string to a Base64 string.
-- @param data The binary string to encode.
-- @return The Base64-encoded string.
function namje_b64.encode(data)
    local len = #data
    local result = {}
    local k = 1 -- Index for the result table

    -- Iterate over the data 3 bytes at a time
    for i = 1, len, 3 do
        -- Get the next 3 bytes (or 0 if padding is needed)
        local b1 = string.byte(data, i)
        local b2 = string.byte(data, i + 1) or 0
        local b3 = string.byte(data, i + 2) or 0

        -- Determine the 4 Base64 indices (6 bits each)
        local c1 = b1 >> 2
        local c2 = (b1 & 0x03) << 4 | (b2 >> 4)
        local c3 = (b2 & 0x0F) << 2 | (b3 >> 6)
        local c4 = b3 & 0x3F

        -- Append the characters to the result
        result[k] = BASE64_CHARS:sub(c1 + 1, c1 + 1) -- Lua strings are 1-indexed
        result[k + 1] = BASE64_CHARS:sub(c2 + 1, c2 + 1)
        result[k + 2] = BASE64_CHARS:sub(c3 + 1, c3 + 1)
        result[k + 3] = BASE64_CHARS:sub(c4 + 1, c4 + 1)
        k = k + 4
    end

    -- Handle padding characters '='
    local pad = len % 3
    if pad == 1 then
        result[#result - 1] = "="
        result[#result] = "="
    elseif pad == 2 then
        result[#result] = "="
    end

    return table.concat(result)
end

--- Decodes a Base64 string back to a binary string.
-- @param b64_data The Base64-encoded string.
-- @return The decoded binary string.
function namje_b64.decode(b64_data)
    -- Remove non-Base64 characters, including newlines/whitespace
    local cleaned_data = b64_data:gsub("[^" .. BASE64_CHARS .. "=]", "")
    local len = #cleaned_data
    local result = {}
    local k = 1 -- Index for the result table

    -- Create a reverse lookup table for decoding
    local decode_map = {}
    for i = 1, #BASE64_CHARS do
        decode_map[BASE64_CHARS:sub(i, i)] = i - 1 -- Store 0-indexed value
    end

    -- Iterate over the Base64 data 4 characters at a time
    for i = 1, len, 4 do
        -- Get the next 4 characters
        local char1 = cleaned_data:sub(i, i)
        local char2 = cleaned_data:sub(i + 1, i + 1)
        local char3 = cleaned_data:sub(i + 2, i + 2)
        local char4 = cleaned_data:sub(i + 3, i + 3)

        -- Get the 6-bit values, treating '=' as 0 for calculation, but skipping output
        local c1 = decode_map[char1]
        local c2 = decode_map[char2]
        local c3 = (char3 == "=" or char3 == "") and 0 or decode_map[char3]
        local c4 = (char4 == "=" or char4 == "") and 0 or decode_map[char4]

        -- Combine the 6-bit chunks into 8-bit bytes
        local b1 = c1 << 2 | c2 >> 4
        local b2 = (c2 & 0x0F) << 4 | c3 >> 2
        local b3 = (c3 & 0x03) << 6 | c4

        -- Append the resulting bytes (characters)
        result[k] = string.char(b1)
        k = k + 1

        -- Only append b2 and b3 if they weren't padding.
        -- If char3 is not '=', it means b2 is a real byte.
        if char3 ~= "=" and char3 ~= "" then
            result[k] = string.char(b2)
            k = k + 1
        end
        -- If char4 is not '=', it means b3 is a real byte.
        if char4 ~= "=" and char4 ~= "" then
            result[k] = string.char(b3)
            k = k + 1
        end
    end

    return table.concat(result)
end