-- This Lua Base64 module and table serialization/deserialization
-- functions were generated by Google Gemini.
-- Date generated: [Insert Date, e.g., June 11, 2025]
-- For more information, visit: https://gemini.google.com/
-- why code it by hand when robots do it faster?

-- Lua Base64 Module (re-used as is, it's solid)
local Base64 = {}

-- Base64 character set
local characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
local encode_map = {}
for i = 1, #characters do
    encode_map[string.byte(characters, i)] = i - 1
end

local decode_map = {}
for i = 0, 63 do
    decode_map[i] = string.char(string.byte(characters, i + 1))
end

--- Encodes a string into Base64.
-- @param data The string to encode.
-- @return The Base64 encoded string.
function Base64.encode(data)
    local buffer = {}
    local len = #data
    local i = 1

    while i <= len do
        local b1 = string.byte(data, i)
        local b2 = string.byte(data, i + 1)
        local b3 = string.byte(data, i + 2)

        local char1 = decode_map[math.floor(b1 / 4)]
        local char2 = decode_map[((b1 % 4) * 16) + math.floor((b2 or 0) / 16)]
        local char3 = decode_map[((b2 or 0) % 16) * 4 + math.floor((b3 or 0) / 64)]
        local char4 = decode_map[(b3 or 0) % 64]

        table.insert(buffer, char1)
        table.insert(buffer, char2)

        if i + 1 <= len then
            table.insert(buffer, char3)
        else
            table.insert(buffer, "=")
        end

        if i + 2 <= len then
            table.insert(buffer, char4)
        else
            table.insert(buffer, "=")
        end

        i = i + 3
    end

    return table.concat(buffer)
end

--- Decodes a Base64 string.
-- @param data The Base64 string to decode.
-- @return The decoded string.
function Base64.decode(data)
    local buffer = {}
    local len = #data
    local i = 1

    -- Ensure length is a multiple of 4, pad with '=' if not
    local padded_data = data
    local padding_needed = (#data % 4)
    if padding_needed ~= 0 then
        padding_needed = 4 - padding_needed
        for _ = 1, padding_needed do
            padded_data = padded_data .. "="
        end
    end
    len = #padded_data -- Update length to use padded_data

    while i <= len do
        local c1_char = padded_data:sub(i, i)
        local c2_char = padded_data:sub(i + 1, i + 1)
        local c3_char = padded_data:sub(i + 2, i + 2)
        local c4_char = padded_data:sub(i + 3, i + 3)

        -- Get numerical values, treating '=' as 0 for arithmetic, but tracking its presence
        local c1 = encode_map[string.byte(c1_char)]
        local c2 = encode_map[string.byte(c2_char)]
        local c3 = (c3_char == "=") and 0 or encode_map[string.byte(c3_char)]
        local c4 = (c4_char == "=") and 0 or encode_map[string.byte(c4_char)]

        -- Error checking for invalid Base64 characters
        if c1 == nil or c2 == nil or (c3_char ~= "=" and c3 == nil) or (c4_char ~= "=" and c4 == nil) then
            error("Invalid Base64 character encountered during decoding.")
        end

        local byte1 = (c1 * 4) + math.floor(c2 / 16)
        local byte2 = ((c2 % 16) * 16) + math.floor(c3 / 4)
        local byte3 = ((c3 % 4) * 64) + c4

        table.insert(buffer, string.char(byte1))
        if c3_char ~= "=" then -- Only add byte2 if c3 is not padding
            table.insert(buffer, string.char(byte2))
        end
        if c4_char ~= "=" then -- Only add byte3 if c4 is not padding
            table.insert(buffer, string.char(byte3))
        end

        i = i + 4
    end

    return table.concat(buffer)
end

--- Lua Table Serialization and Deserialization with Base64 Encoding
namje_serializer = {}

-- Forward declarations for mutually recursive functions
local deserializeValue
local parseList

--- Serializes a Lua value into the custom string format.
-- @param value The Lua value to serialize.
-- @return The serialized string representation.
local function serializeValue(value)
    local valueType = type(value)
    if valueType == "number" then
        return "N" .. tostring(value)
    elseif valueType == "string" then
        -- Use %q for proper string escaping, including quotes
        return "S" .. string.format("%q", value)
    elseif valueType == "boolean" then
        return "B" .. tostring(value)
    elseif valueType == "nil" then
        return "Z" -- Zero, for nil
    elseif valueType == "table" then
        local parts = {}
        local is_array = true
        local max_idx = 0
        local count_keys = 0 -- To distinguish empty tables from empty arrays

        -- First pass: Check for array characteristics and count keys
        for k, _ in pairs(value) do
            count_keys = count_keys + 1
            if type(k) == "number" and k >= 1 and math.floor(k) == k then
                max_idx = math.max(max_idx, k)
            else
                is_array = false -- Found a non-integer key or key < 1
            end
        end

        -- A table is considered an array if:
        -- 1. It has no non-integer keys (is_array is still true)
        -- 2. It has all consecutive integer keys from 1 up to its numeric length (#value)
        --    AND its total number of keys matches its numeric length.
        --    This handles sparse arrays or tables with numerical keys that aren't dense sequences.
        if is_array and max_idx == #value and count_keys == #value then
             -- If it looks like an array, iterate numerically to ensure order
            for i = 1, #value do
                table.insert(parts, serializeValue(value[i]))
            end
            return "A[" .. table.concat(parts, ",") .. "]"
        else
            -- Treat as associative table if not a perfect array or if it has non-numeric keys
            -- Sort keys for consistent serialization output (optional but good for debugging/testing)
            local sorted_keys = {}
            for k, _ in pairs(value) do
                table.insert(sorted_keys, k)
            end
            table.sort(sorted_keys, function(a, b)
                local ta, tb = type(a), type(b)
                if ta == tb then
                    if ta == "number" then return a < b end
                    if ta == "string" then return a < b end
                end
                -- Prioritize numbers over strings, for consistent sorting of mixed keys
                if ta == "number" then return true end
                if tb == "number" then return false end
                return tostring(a) < tostring(b) -- Fallback for other types or different types
            end)

            for _, k in ipairs(sorted_keys) do
                local serialized_key = serializeValue(k)
                local serialized_value = serializeValue(value[k])
                table.insert(parts, serialized_key .. ":" .. serialized_value)
            end
            return "T{" .. table.concat(parts, ",") .. "}"
        end
    else
        -- Fallback for unsupported types, or error out
        error("Unsupported type for serialization: " .. valueType .. " (value: " .. tostring(value) .. ")")
    end
end

-- Helper function to unescape Lua string literals without using 'load'
local function unescapeStringLiteral(s_literal)
    local unescaped_parts = {}
    local i = 1
    local len = #s_literal

    -- Remove outer quotes (they should be there from %q)
    if s_literal:sub(1,1) == "\"" and s_literal:sub(len,len) == "\"" then
        i = 2
        len = len - 1
    end

    while i <= len do
        local char = s_literal:sub(i, i)
        if char == '\\' then
            local next_char_idx = i + 1
            if next_char_idx > len then
                error("Malformed escape sequence at end of string literal.")
            end
            local next_char = s_literal:sub(next_char_idx, next_char_idx)

            if next_char == 'a' then table.insert(unescaped_parts, "\a"); i = i + 2
            elseif next_char == 'b' then table.insert(unescaped_parts, "\b"); i = i + 2
            elseif next_char == 'f' then table.insert(unescaped_parts, "\f"); i = i + 2
            elseif next_char == 'n' then table.insert(unescaped_parts, "\n"); i = i + 2
            elseif next_char == 'r' then table.insert(unescaped_parts, "\r"); i = i + 2
            elseif next_char == 't' then table.insert(unescaped_parts, "\t"); i = i + 2
            elseif next_char == 'v' then table.insert(unescaped_parts, "\v"); i = i + 2
            elseif next_char == '\\' then table.insert(unescaped_parts, "\\"); i = i + 2
            elseif next_char == '"' then table.insert(unescaped_parts, "\""); i = i + 2
            elseif next_char == "'" then table.insert(unescaped_parts, "'"); i = i + 2
            elseif next_char == 'x' then -- Hex escape \xDD
                local hex_digits = s_literal:sub(next_char_idx + 1, next_char_idx + 2)
                if #hex_digits < 2 or not hex_digits:match("^[0-9a-fA-F][0-9a-fA-F]$") then
                    error("Invalid hex escape sequence: \\x" .. hex_digits .. " at pos " .. i)
                end
                local byte_val = tonumber(hex_digits, 16)
                table.insert(unescaped_parts, string.char(byte_val))
                i = i + 4
            elseif string.match(next_char, "^%d$") then -- Octal escape \DDD
                local octal_digits_match = s_literal:sub(next_char_idx):match("^%d%d?%d?")
                if not octal_digits_match or #octal_digits_match == 0 then
                    error("Invalid octal escape sequence (missing digits): \\ at pos " .. i)
                end
                local byte_val = tonumber(octal_digits_match, 8)
                if byte_val == nil or byte_val > 255 then
                     error("Invalid octal escape sequence: \\" .. octal_digits_match .. " at pos " .. i)
                end
                table.insert(unescaped_parts, string.char(byte_val))
                i = i + 1 + #octal_digits_match
            elseif next_char == 'z' then -- Skips following whitespace
                local ws_start = next_char_idx + 1
                while ws_start <= len and s_literal:sub(ws_start, ws_start):match("^%s$") do
                    ws_start = ws_start + 1
                end
                i = ws_start
            elseif next_char == 'u' and s_literal:sub(next_char_idx + 1, next_char_idx + 1) == '{' then
                error("Unicode escape sequences \\u{} are not supported by this deserializer.")
            else -- Unknown escape sequence, treat backslash as literal
                table.insert(unescaped_parts, char)
                i = i + 1
            end
        else
            table.insert(unescaped_parts, char)
            i = i + 1
        end
    end
    return table.concat(unescaped_parts)
end

-- Define parseList after forward declaration
parseList = function(str, start_pos, end_delimiter)
    local list_items = {}
    local current_pos = start_pos

    while current_pos <= #str do
        if str:sub(current_pos, current_pos) == end_delimiter then -- Found end delimiter
            break
        end

        if current_pos > start_pos then -- Only check for comma if not the very first item
            local char_at_current_pos = str:sub(current_pos, current_pos)
            if char_at_current_pos == "," then
                current_pos = current_pos + 1 -- Skip the comma
                if current_pos > #str then
                    error("Malformed list: trailing comma at pos " .. (current_pos -1))
                end
                -- If a comma is followed immediately by the end delimiter, that means an empty element, which isn't allowed in this format
                if str:sub(current_pos, current_pos) == end_delimiter then
                    error("Malformed list: empty element before '" .. end_delimiter .. "' at pos " .. current_pos)
                end
            elseif char_at_current_pos ~= end_delimiter then
                -- If it's not the first item, not a comma, and not the end delimiter, it's an error
                error("Malformed list: Expected ',' or '" .. end_delimiter .. "' at position " .. current_pos .. ". Found: '" .. char_at_current_pos .. "'")
            end
        end

        local val, next_char_pos = deserializeValue(str, current_pos)
        table.insert(list_items, val)
        current_pos = next_char_pos
    end

    -- Check if the loop ended because of the delimiter or end of string
    if current_pos > #str then -- Reached end of string prematurely
        error("Unterminated list, expected '" .. end_delimiter .. "' before end of string at pos " .. current_pos)
    elseif str:sub(current_pos, current_pos) ~= end_delimiter then
        error("Internal parsing error: Expected '" .. end_delimiter .. "' at position " .. current_pos)
    end

    return list_items, current_pos + 1 -- Return the parsed list and the position after the delimiter
end

-- Define deserializeValue after forward declaration
deserializeValue = function(str, pos)
    local start_char = str:sub(pos, pos)
    local current_pos = pos + 1 -- Position after the type identifier

    if start_char == "N" then
        local num_str_match = str:sub(current_pos):match("^-?%d+%.?%d*[eE]?[%-+]?%d*")
        if not num_str_match then error("Invalid number format during deserialization near pos " .. pos) end
        return tonumber(num_str_match), current_pos + #num_str_match
    elseif start_char == "S" then
        local quote_start = current_pos
        if str:sub(quote_start, quote_start) ~= "\"" then
            error("Malformed string: expected opening quote at pos " .. quote_start)
        end

        local match_end_pos = -1
        local temp_scan_pos = quote_start + 1
        while temp_scan_pos <= #str do
            local char = str:sub(temp_scan_pos, temp_scan_pos)
            if char == '"' then
                if str:sub(temp_scan_pos - 1, temp_scan_pos - 1) ~= '\\' then
                    match_end_pos = temp_scan_pos
                    break
                end
            end
            temp_scan_pos = temp_scan_pos + 1
        end

        if match_end_pos == -1 then error("Unterminated string during deserialization near pos " .. pos) end

        local s_literal = str:sub(quote_start, match_end_pos)
        local unescaped_s = unescapeStringLiteral(s_literal)
        return unescaped_s, match_end_pos + 1
    elseif start_char == "B" then
        local bool_str_true = str:sub(current_pos, current_pos + 3)
        local bool_str_false = str:sub(current_pos, current_pos + 4)
        if bool_str_true == "true" then
            return true, current_pos + 4
        elseif bool_str_false == "false" then
            return false, current_pos + 5
        else
            error("Invalid boolean value during deserialization near pos " .. pos)
        end
    elseif start_char == "Z" then
        return nil, current_pos
    elseif start_char == "A" then
        -- EXPECT '[' immediately after 'A'
        if str:sub(current_pos, current_pos) ~= "[" then
            error("Malformed array: Expected '[' after 'A' at position " .. current_pos)
        end
        local content_start_pos = current_pos + 1 -- Move past '['

        local tbl, next_char_pos = parseList(str, content_start_pos, "]")
        return tbl, next_char_pos
    elseif start_char == "T" then
        local tbl = {}
        -- EXPECT '{' immediately after 'T'
        if str:sub(current_pos, current_pos) ~= "{" then
            error("Malformed table: Expected '{' after 'T' at position " .. current_pos)
        end
        local content_start_pos = current_pos + 1 -- Move past '{'

        -- Special handling for empty tables: T{}
        if str:sub(content_start_pos, content_start_pos) == "}" then
            return tbl, content_start_pos + 1
        end

        -- Find the closing brace for the current table to bound the loop
        local brace_end_pos = -1
        local nested_level = 0
        local scan_pos = content_start_pos
        while scan_pos <= #str do
            local char = str:sub(scan_pos, scan_pos)
            -- Only increment/decrement level for delimiters *within* content
            if char == '{' or char == '[' then
                nested_level = nested_level + 1
            elseif char == '}' then
                if nested_level == 0 then
                    brace_end_pos = scan_pos
                    break
                else
                    nested_level = nested_level - 1
                end
            elseif char == ']' then
                if nested_level > 0 then
                    nested_level = nested_level - 1
                end
            end
            scan_pos = scan_pos + 1
        end

        if brace_end_pos == -1 then
            error("Unterminated table during deserialization near pos " .. pos .. ". Expected matching '}'")
        end

        local current_scan_pos = content_start_pos

        while current_scan_pos < brace_end_pos do
            if current_scan_pos > content_start_pos then -- Only check for comma if not the very first pair
                local char_at_current_pos = str:sub(current_scan_pos, current_scan_pos)
                if char_at_current_pos == "," then
                    current_scan_pos = current_scan_pos + 1 -- Skip the comma
                    if current_scan_pos >= brace_end_pos then
                         error("Malformed table: trailing comma at pos " .. (current_scan_pos -1))
                    end
                else
                    error("Malformed table: Expected ',' or '}' at position " .. current_scan_pos .. ". Found: '" .. char_at_current_pos .. "'")
                end
            end

            local key, key_end = deserializeValue(str, current_scan_pos)
            if key_end > #str or str:sub(key_end, key_end) ~= ":" then
                error("Expected ':' after key during deserialization near pos " .. key_end .. ". Found: '" .. (str:sub(key_end, key_end) or "End of string") .. "'")
            end
            
            local val, val_end = deserializeValue(str, key_end + 1)
            tbl[key] = val
            current_scan_pos = val_end
        end

        if current_scan_pos ~= brace_end_pos then
            error(string.format("Internal parsing error: Table content did not end exactly at closing brace for table started at pos %d. Expected final pos: %d, Actual: %d", pos, brace_end_pos, current_scan_pos))
        end
        return tbl, brace_end_pos + 1
    else
        error("Unknown type identifier: '" .. start_char .. "' at position " .. pos)
    end
end

--- Converts a Lua table into a Base64 string.
-- This function first serializes the table into a custom string format,
-- and then encodes that string into Base64.
-- @param luaTable The Lua table to convert.
-- @return A Base64 string representation of the table.
function namje_serializer.encode(luaTable)
    local serialized_string = serializeValue(luaTable)
    return Base64.encode(serialized_string)
end

--- Converts a Base64 string back into a Lua table.
-- This function first decodes the Base64 string, and then deserializes
-- the resulting string back into a Lua table.
-- @param base64String The Base64 string to convert.
-- @return The original Lua table.
function namje_serializer.decode(base64String)
    local decoded_string = Base64.decode(base64String)
    local tbl, _ = deserializeValue(decoded_string, 1)
    return tbl
end